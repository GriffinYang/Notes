# Linux Notes

终端模式又称为命令行模式或字符模式，默认情况下Linux提供6个终端，可以使用组合键**Ctrl+Alt+F1**进入第一个终端，使用组合键Ctrl+Alt+F2进入第二个终端，其他终端的组合键以此类推。实际上，**终端又叫tty，Linux系统定义了6个tty，分别从tty1到tty6。**tty是Teletype的简写，Teletype是最早出现的一种终端设备，很像电传打字机。在Linux系统中，在特殊文件目录/dev下有一些文件与之对应，比如/dev/tty1、/dev/tty2等，**从tty1到tty6又称为虚拟终端。如果想回到桌面模式，只需要使用组合键Ctrl+Alt+F7即可。**

"~"是用户home目录（又叫“用户家目录”）的简写

"#"是一个提示符，出现"#"说明目前的用户是有超级权限的root用户，而一般用户的提示符是"$‘

date命令:使用该命令，我们可以查看当前时间。但是需要注意的是Linux严格区分大小写，因此该命令应当保持小写。除此之外该命令的默认返回值格式为标准时间格式，为了实现不同的格式时间的输出，Linux提供了一个时间的格式的参数: +%f%f%f， 如我们需要输出 yyyy-mm-dd 则可以使用：

```bash
date +%Y%-m%-d
```

## These are the most common formatting characters for the date command

%D – Display date as mm/dd/yy

%Y – Year (e.g., 2020)

%m – Month (01-12)

%B – Long month name (e.g., November)

%b – Short month name (e.g., Nov)

%d – Day of month (e.g., 01)

%j – Day of year (001-366)

%u – Day of week (1-7)

%A – Full weekday name (e.g., Friday)

%a – Short weekday name (e.g., Fri)

%H – Hour (00-23)

%I – Hour (01-12)

%M – Minute (00-59)

%S – Second (00-60)

ls命令：该命令用于列出目录下的内容，默认无参数的时候，仅会列出目录中的内容的名称。 如果我们加上参数'-l'则会显示每一个文件的具体信息，其包括了文件类型，名称，权限，所属用户等。当我们需要获取某一个文件的具体内容时则为其追加一个该文件或者目录的名称作为参数即可

cat:使用该命令+文件名则可以显示该文件的文本内容

## Linux的启动顺序

1)BOIS进行POST(Power On Self Test)自检，检查硬件无误后---->

2)进入引导程序，IOS默认会从硬盘上的第0柱面、第0磁道、第一个扇区中读取被称为MBR(引导记录)。其中一个扇区数512个字节，其存放的是一段引导程序和分区信息，程序和分区信息，其中引导程序部分占用446字节，另外64字节是磁盘分区表DPT，最后两字节是MBR的结束位，因为MBR中的引导程序也是可以修改的，所以可以利用这个特性实现多操作系统共存,如果使用Grub作为引导系统的程序，则由于Grub本身比较大，所以常见的方式是在MBR中写入Grub的地址，这样系统实际会载入Grub作为操作系统的引导程序。--->

3)运行Grub引导程序，其首先加载/sbin/init程序，该程序依据/etc/inittab配置信息进行初始化操作，其中核心是确定系统的运行等级，默认等级为3,即id:3:initdefault --->

4)此时再根据/etc/inittab配置文件中的si::sysinit:/etc/rc.d/rc.sysinit来执行/etc/rc.sysinit脚本，该脚本将会设置系统变量、网络配置，并启动swap、设定/proc、加载用户自定义模块、加载内核设置等。--->

5)根据runlevel值来启动对应的服务，如果值为3，就会运行/etc/rc3.d/下的所有脚本，如果值为5，就会运行/etc/rc5.d/下的所有脚本。---->

6)运行/etc/rc.local --->

7)会生成终端或X Window来等待用户登录

## 系统运行级别

Linux默认有7个运行级，从运行级0到运行级6，每一个运行级所对应的含义如下：

1.运行级0：关机。

2.运行级1：单用户模式，系统出现问题时可使用这种模式进入系统维护，典型的使用场景是在忘记root密码时可进入此模式修改root密码。

3.运行级2：多用户模式，但是没有网络连接。

4.运行级3：完全多用户模式，这也是Linux服务器最常见的运行级。

5.运行级4：保留未使用。

6.运行级5：窗口模式，支持多用户，支持网络。

7.运行级6：重启。

## /etc/rcN.d/

该程序目录下的脚本会在每个运行级的启动时执行，其中N为运行级，例如/etc/rc3.d/目录下的脚本会在运行级3的启动时执行。其中每一个脚本的实际内容分别是以K或S开头、后跟两位数字、再是链接到上层init.d目录中的服务脚本。系统在启动过程中，会首先运行以K开头的脚本，全部运行完毕后再运行以S开头的脚本，在运行所有K开头的脚本时，又会严格按照K后面的数字大小依次来运行，也就是数字小的先运行，数字大的后运行。同样，在运行S开头的脚本时，也是按照这个原则进行的，即先运行数字小的脚本，再运行数字大的脚本。K和S的意思分别是停止（kill）和启动（start），只要定义好不同运行级需要启动和停止的服务，就可以让系统在不同的运行级下启动和关闭不一样的服务

Grub的启动分为两步，第一段以stage1作为主引导程序，主要用于定位和装载并转交控制权给stage2，也就是第二段引导程序。其中stage1是MBR的一个副本，在Grub目录下还有很多1_5结尾的文件，它们便是各种文件系统的驱动文件，当stage1从不同的文件系统中读取stage2时需要使用这些驱动文件。对Grub的配置可以通过修改Grub的配置文件完成，一般配置文件为/boot/grub/grub.conf。修改后的配置将直接影响下次引导时的行为

## grub的配置

grub作为系统的引导程序，其配置文件地址为/boot/grub/grub.conf。我们可以通过修改该配置文件来配置引导程序，其具体内容包含：

1).default：其值为一个数字，用于选取载入哪一个title所对应的系统，如果存在多个title也就是多个子系统，则使用0选取第一个title作为默认系统，使用1选取第二个title作为默认系统，以此类推。

2).timeout:用以设置引导程序的超时时间，单位为秒，默认为0，表示不超时。如果选取超时，则默认载入第一个title作为默认系统，在这指定的时间内，用户可以通过上下键对于title进行选取，此时可以重置计时器，此为，用户可以直接使用enter跳过引导超时从而直接进入该title的系统。

3).splashimage:用以设置引导程序的启动画面，其值为一个文件名，如果不存在，则不会显示启动画面。其地址的格式由引导系统的不同而改变：

如果系统使用的是sata磁盘，则命名规则为：第一块磁盘是sda，第二块磁盘是sdb，以此类推。对磁盘进行分区后的分区命名规则是，第一个磁盘的第一个分区是sda1，第一个磁盘的第二个分区是sda2，第二个磁盘的第一个分区是sdb1，第二个磁盘的第二个分区是sdb2。而Grub使用hd0代表第一块磁盘，而这里（hd0,0）的含义是第一块磁盘的第一个分区，如(hd0,0)/grub/splash.xpm.gz的绝对路径就是/boot/grub/splash.xpm.gz。这个文件是一个压缩包，但是Grub在启动时会自动对该文件做解压缩

4).hiddenmenu是设置启动时是否显示菜单

5).title是系统引导时显示的名字，这只是一种识别性的文字，可以任意修改

6).root（hd0,0）指定内核放置的分区为第一磁盘的第一个扇区，后面的内核和initrd的地址都以该地址作为根路径

7).kernel 参数指定内核的路径， 其后可以追加参数在内核启动时传入给内核

8).initrd 指定initrd文件的路径

initrd文件，其英文含义是boot loader initialized RAM disk，也就是boot loader用于初始化的内存磁盘，是系统启动时的临时文件系统，kernel通过读取initrd来获得各种可执行文件和设备驱动，并挂载真实的文件系统，然后卸载这个临时文件系统。在桌面或者Linux服务器中，initrd文件只是一个临时的文件系统，其生命周期很短，只会用作挂载真实文件系统的一个接力，在很多嵌入式系统中，由于不需要外接大存储设备，所以initrd会作为永久的文件系统直接使用。

**帮助文档:** man -f command:获取该command的介绍，也可以使用"info command"

## UID和GID

UID即为User ID，翻译过来即为用户名，然而实际上Linux是以一个32位的数字来记录不同的用户的(一般从500开始计算)，Linux使用该段数字与我们所使用的用户名进行映射。这也就意味着同一台Linux系统可以同时拥有四十多亿个用户，这其中分为了普通用户，根用户和系统用户:

**普通用户:** 是指所有使用Linux系统的真实用户，这类用户可以使用用户名及密码登录系统。Linux有着极为详细的权限设置，所以一般来说普通用户只能在其家目录、系统临时目录或其他经过授权的目录中操作，以及操作属于该用户的文件。通常普通用户的UID大于500，因为在添加普通用户时，系统默认用户ID从500开始编号。

**根用户:** 也就是root用户，它的ID是0，也被称为超级用户，root账户拥有对系统的完全控制权：可以修改、删除任何文件，运行任何命令。所以root用户也是系统里面最具危险性的用户，root用户甚至可以在系统正常运行时删除所有文件系统，造成无法挽回的灾难。所以一般情况下，使用root用户登录系统时需要十分小心。

**系统用户:** 是指系统运行时必须有的用户，但并不是指真实的使用者。比如在RedHat或CentOS下运行网站服务时，需要使用系统用户apache来运行httpd进程，而运行MySQL数据库服务时，需要使用系统用户mysql来运行mysqld进程。在RedHat或CentOS下，系统用户的ID范围是1~499。

GID:在Linux系统中除了有用户之外，还有“用户组”的概念，不同的用户组同样也是用数字来区分的，这种用于区分不同用户组的ID被称为Group ID，也就是GID。

## /etc/passwd 和 /etc/shadow

**前者原本是储存用户信息和密码的文件，但是后来密码部分被单独提取出来而置于后者之中。其中前者的格式时固定的，每一条记录均有六个分号所分隔，继而获得七段不同的信息。这七段信息内容分别代表了**:

1.用户名

2.用户密码，现在是默认值X,其内容已转移至shadow文件之中

3.UID

4.GID

5.说明栏

6.用户家目录

7.用户所使用的shell程序

**后者则为密码的储存区域，其中密码均以加密的方式储存。该文件默认仅有root用户才有资格查看，当然root用户可以对该权限进行设置。其内容由八个冒号分为了九段，其含义如下**:

1.以UID字符串表示的用户名

2.密码，已加密状态

3.密码最近的修改日期:这个日期是自1970年1月1日到修改日的天数

4.密码不可修改的天数:密码修改多少天以后不可修改密码，如果是0则可以随时修改

5.密码重新修改的天数:提醒用户修改密码的天数

6.密码失效前警告的天数:密码失效前提醒用户修改密码的天数

7.密码失效的宽限天数:密码有效性到期，过几天后可以完全不可以登陆系统

8.密码的失效日期:一般为空

9.保留字段:未被使用

## 用户的创建

**步骤**:

使用useradd创建新用户->

在/etc/passwd和/etc/shadow末尾追加一条记录，同时会分配给该用户一个UID->

在/home目录下创建以用户名为文件名的目录->

将/etc/skel文件夹下的所有文件全部复制到该创建的新用户的目录之下，而这个/etc/skel可以看作是一个模板，任何一个新用户的根目录都是以/etc/skel为基础，并且在创建新用户时，会自动将/etc/skel下的文件复制到新用户的根目录下。因此我们可以改变该目录从而使得创建文件是创建指定的内容，虽然/etc/skel命令查看，可以发现这个目录下“什么都没有”，但事实上，该目录下面有很多隐藏文件使用命令ls-la /etc/skel查看隐藏文件->

新建一个与该用户名一样的用户组,并将该用户添加至该用户组之中

## 密码的修改

创建用户后，该用户实际上还没有登录系统的权限，因为在不设置密码的情况下，在/etc/shadow中该用户记录中以冒号分隔的第二列将显示为两个感叹号“！！”，这说明不允许该用户登录系统。因此，需要同时设置用户的密码才行，设置命令是passwd后接用户名

```bash
passwd userName
```

与root用户使用这个命令的方式不同，普通用户在运行这个命令时，后面不能跟参数，哪怕是自己的用户名也不行。比如说使用john登录，然后采用passwd john命令，系统就会立刻报错，提示只有root用户才可以在后面跟上用户名

## 用户修改

usermod,用以将用户的属性修改为指定的属性。

```bash
usermod -u newUID userName
usermod -d newDirectory-m userName #该参数会自动新建该目录以作为用户的根目录
usermod -g newGroup userName
```

## 用户删除

userdel:使用这个命令会将删除alice在/etc/passwd和/etc/shadow中的记录。但是从数据安全方面考虑，默认情况下，删除用户时并不会删除原来用户的家目录和邮件信息。可以使用-r参数同时删除用户家目录和该用户的邮件。注意，一旦执行了这条命令，该用户的相关文件就会被全部删除。

## 组的创建和删除

组的创建和与用户大致相同，我们通过groupadd命令来创建组，并且在/etc/group文件中追加一条记录。同时使用groupdel命令来删除组。除此之外我们还可以使用groupmod命令来修改组的属性。但是需要注意的是当该组中拥有成员用户时，该组将无法被删除。

## 用其他用户的身份执行命令：sudo和su

su:su是切换用户的意思。在不加参数的情况下，su命令默认表示切换到root用户，之后只要输入root密码就可以切换身份为root了，完成操作后，使用exit命令可以退出root切换到原先的用户

su命令后面还可以加上一个“-”参数，就是键盘上的中横线。加上这个参数后，切换成root用户时，不但身份变成了root，而且还能应用root的用户环境。所谓“用户环境”就是/etc/passwd中定义的用户家目录、使用的Shell，以及关于这个用户的个性化设置等

su-命令后还可以继续跟其他的用户名作为参数，这样就可以切换成指定用户的身份。比如说用户john在使用过程中需要临时切换成用户user1，这时就可以使用su-user1命令切换用户，但是同样需要知道user1的密码

使用su命令我们需要知晓管理员的密码，而sudo则只需要输入用户自己的密码即可以管理员身份执行命令。该命令的使用方式是在sudo后跟上需要执行的命令，比如说sudo passwd user1，即使用root的身份修改user1的密码。运行该命令时，系统首先检查/etc/sudoers，判断该用户是否有执行sudo的权限，在确定有执行权限后，系统要求用户输自己的密码，如果密码输入正确，则会以root用户的身份运行passwd user1命令。但是前提是该用户已在sudoer文件中增加该用户或者将其所在的组设置为sudo的管理组。此时使用visudo命令即可

**其中基本格式为"user ALL=(ALL:ALL) [NOPASSWD:]ALL"**：

第一段：用户名或者用户组，表示谁有权限来使用后面的配置。%sudo代表sudo组下的所有用户

第二段：表示来源地，即从哪执行这条命令。ALL表示所有计算机

第三段：表示sudo可以切换到什么用户。ALL表示所有用户

第四段：表示sudo可以切换到哪些组下的用户。ALL表示所有组

第五段：表示sudo之后能够执行的命令。如果是"NOPASSWD:ALL"则表示执行任意命令都不需要密码

严格来说，sudo并不是真的切换了用户，而是使用其他用户的身份和权限执行了命令。

## 定时任务at:该命令是用以设置一个定时任务->

```bash
at now + 40 minutes #定义一个自现在起以后三十分后的任务
/sbin/shutdown-h now #设置关机命令
#ctrl+d结束   
```

设置一个定时任务后可以使用stq来查看已设置的定时任务，使用atrm 任务编号以删除该任务

```bash
atq
#任务列表
atrm 1 #删除该任务
```

at的时间也可以设置为一个具体值:

```bash
at 00:00 2022-7-28
/sbin/shutdown-h now #设置关机命令
#ctrl+d结束 
```

## 周期性定时任务cron

我们可以通过crontab来设置自己的定时任务，其语法为:

```bash
* * * * * command
```

前面5个*可以用来定义时间，第一个*表示分钟，可以使用的值是1~59，每分钟可以使用*和*/1表示；第二个*表示小时，可以使用的值是0~23；第三个*表示日期，可以使用的值是1~31；第四个*表示月份，可以使用的值是1~12；第五个*表示星期几，可以使用的值是0~6，0代表星期日；最后是执行的命令。

```bash
*/1 * * * * command #每分钟执行一次
* */1 * * * command #每小时执行一次
* 12-13/12 * * * command #每天中午12点到13点每隔12小时执行一次
30 23 * * * command #每天的23点30分执行一次
30 23 1 1 * command #每年的1月1日的23点30分执行一次
30 23 * * 0 command #每周的周日的23点30分执行一次
```

设置完成后，可以使用crontab-l查看设置的任务，也可以使用crontab-r删除所有的任务除此之外我们还可以使用'cat /etc/crontab' 来设置周期任务

**这里的格式->** \* \* \* \* \* userName command to be executed:

```bash
*/1 * * * * root command #每分钟由root身份执行一次
```

## 文件和目录管理

在Linux中万物皆文件，这些文件所沿用的也是目录树的文件存储结构，即一个目录参访子目录和文件的格式，其中所有的目录都存放在一个根目录下，在Linux中这个根目录就是"/"，我们可以使用" cd /"来对其进行访问。

而FHS（文件系统层次标准）定义了在根目录下的主要目录以及每个目录应该存放什么文件，以下则为FHS的目录结构：

<table>
    <tr>
    <th>目录</th>
    <th>用途</th>
    </tr>
    <tr>
    <td>/bin</td>
    <td>常见的用户指令</td>
    </tr>
    <tr>
    <td>/boot</td>
    <td>内核和启动文件</td>
    </tr>
    <tr>
    <td>/dev</td>
    <td>设备文件</td>
    </tr>
    <tr>
    <td>/etc</td>
    <td>系统和服务的配置文件</td>
    </tr>
    <tr>
    <td>/home</td>
    <td>普通用户的家目录</td>
    </tr>
    <tr>
    <td>/lib</td>
    <td>系统函数库目录</td>
    </tr>
    <tr>
    <td>/lost+found</td>
    <td>ext3文件系统所需目录用于磁盘检查</td>
    </tr>
    <tr>
    <td>/mnt</td>
    <td>系统加载文件系统时常用的挂载点</td>
    </tr>
    <tr>
    <td>/opt</td>
    <td>第三方软件安装目录</td>
    </tr>
    <tr>
    <td>/proc</td>
    <td>模拟文件系统</td>
    </tr>
    <tr>
    <td>/root</td>
    <td>root用户的家目录</td>
    </tr>
    <tr>
    <td>/sbin</td>
    <td>存放系统管理命令</td>
    </tr>
    <tr>
    <td>/tmp</td>
    <td>存放临时文件的目录/td>
    </tr>
    <tr>
    <td>/usr</td>
    <td>存放于用户直接相关的文件和目录</td>
    </tr>
    <tr>
    <td>/media</td>
    <td>系统用来挂载光驱等临时文件系统的挂载点</td>
    </tr>
</table>

## 文件路径

1.绝对路径: Linux系统采用了目录树的文件组织结构，在Linux下每个目录或文件都可以从根目录处开始寻找,而绝对路径一定是以“/”开头的

2.pwd：想要确定当前所在的目录，可以使用以下pwd命令查看

3.(..)和(.)：在每个目录下，都会固定存在两个特殊目录，分别是一个点（.）和两个点（..）的目录。一个点（.）代表的是当前目录，两个点（..）代表的是当前目录的上层目录。在Linux下，所有以点开始的文件都是“隐藏文件”，对于这类文件，只使用命令ls-l是看不到的，必须要使用ls-la才可以看到

4.相对目录：假设当前目录在/usr/local下，那么它的上层目录（/usr目录）可以用../表示，而/usr/local的下层目录（src）则可以用./src表示

## 文件的操作

1.touch(创建文件):使用touch命令，参数为想要创建文件的文件名:

```bash
touch new.txt
```

事实上，如果在使用touch命令创建文件的时候，当前目录中已经存在了这个文件，那么这个命令不会对当前的同名文件造成影响，因为它并不会修改文件的内容，但是会更新修改时间

2.(rm):删除文件，其与创建文件用法一致:

```bash
rm new.txt
```

3.(mv):移动元素，其后接两个参数:目标文件和目标目录:

```bash
mv new.txt /usr/rongxin/target/
```

除了移动文件，使用mv还可以重命名文件:

```bash
mv new.txt newName.txt
```

而在Linux下的目录也是一种“文件”，所以本节中所讲解的mv命令也同样适用于对目录的操作

4.(cat):查看文件内容，其后接文件名:

```bash
cat install.log
```

5.(head):有时候文件非常大，使用cat命令显示出来的内容太多，而我们可能并不想查看所有内容，只是想看看文件开始部分的内容，这时候就可以使用head命令了，后面跟上需要查看的文件名就可以了。默认情况下，head将显示该文件前10行的内容,也可以使用-n参数指定显示的行数：

```bash
head -n 20 install.log
```

6.(tail):tail命令与head命令非常类似。当文件很大时，可以使用该命令查看文件尾部的内容，默认情况下tail也是只显示文件的最后10行内容，同样可以使用-n参数指定显示的行数，我们还可以添加-f参数动态的查看文件了，这也就意味着，如果一个文件在随时更新，那么我们所看到的内容也就在随时的更新，如查看日志文件

7.(dos2unix):文件格式转换:该命令是DOS to UNIX的简写，也许你从字面上可以大概猜到它的作用，就是可以把DOS格式的文本文件转变成UNIX下的文本文件。之所以有这样的需求是因为Linux和Windows系统是可以通过文件共享的方式共享文件的，当把Windows下的文本文件移动到Linux下时，会由于系统之间文本文件的换行符不同而造成文件在Linux下的读写操作有问题。该命令的使用方式非常简单直接，后面跟上需要转换的文件名即可

## 目录操作

1.(cd):切换目录，其后接目录名,其实际上就是change directory的缩写

2.(mkdir):该命令是make directory的简写，其用途是创建目录，使用方法是在后面跟上目录的名称,但是默认情况下，一次只能创建一级目录，弱国需要一次性创造多级目录，可以添加-p参数:

```bash
mkdir -p /root/dir1/dir2/target
```

3.(rmdir和rm):删除目录，前者只可删除一个没有存放文件的目录，如果需要删除该目录首先需要清除其内容，为了简化这一过程，我们使用rm添加参数-r的方法删除一个含有子目录和文件的目录，如果需要跳过系统的安全检测(询问是否删除)，我们可以直接在r后添加一个f来规避该提示：

```bash
rm -rf /root/dir1/dir2/target
```

4.(cp):该命令是copy的简写，用于复制文件和目录。如果是复制文件，其后接两个参数，第一个参数是要复制的源文件，第二个参数是要复制到的目录或复制后的文件名

```bash
cp target.txt /targetpath/target-Copy.txt #复制文件至指定的位置且重命名为target-Copy.txt
cp target.txt /targetpath/ #复制文件至指定的位置且文件名不变
```

复制目录同样也是使用cp命令。相对于复制文件，复制目录只需要使用-r参数即可

**注:** 我们可以使用"cp * targetPath"将当前目录下的所有文件复制到指定目录下

## 文件的时间戳

不管是哪种系统，几乎所有的程序都会读写系统文件，默认情况下，一旦发生写文件操作，该文件的时间戳将会立刻得到更新。因此可以利用这种特性来有选择性地备份一些文件（又叫差异备份）。比如有一个目录中有若干个文件，我们每天需要备份一次。最简单的办法是每天使用cp操作全部备份一次，但是这种做法在文件总大小比较大的情况下会显得效率不高。如果有一些文件很大，但是和上一次备份相比并没有发生任何变化，实际上是不需要进行备份的，只需要找出在上一次备份之后发生变化的文件，然后备份这些文件即可。

简而言之，就是我们在备份某个文件之前，将其时间戳与所在文件的时间戳进行比较，如果其内部文件的时间戳大于所在文件的时间戳即表名该文件已被修改，则我们将其进行备份

**注:** 我们可以通过touch time_stamp来查看时间戳

## 文件和目录的权限

当我们使用"ls -al"查看目录下的文件和子目录时，其第一列的前十个字符中，第一个字符会显示文件的类型，如果为目录则为d，普通文件为一个横杠，链接文件则为l,块文件为b,字符文件为c,套接字文件为s,管道文件为p；而后面九个字符分别代表了其所有权，分别代表了用户，组和其他用户。每组都是rwx的组合，如果拥有读权限，则该组的第一个字符显示r，否则显示一个小横线；如果拥有写权限，则该组的第二个字符显示w，否则显示一个小横线；如果拥有执行权限，则第三个字符显示x，否则显示一个小横线。

第二列则表示连接数，目录文件的连接数是该目录中包含其他目录的总个数+2，也就是说，如果目录A中包含目录B和C，则目录A的连接数为4

第三列代表该文件的所有人，第四列代表该文件的所有组，第五列是该文件的大小，第六列是该文件的创建时间或最近的修改时间，第七列是文件名。

## 文件的隐藏属性

Linux下的文件还有一些隐藏属性，必须使用lsattr来显示，默认情况下，文件的隐藏属性都是没有设置的。查看文件的隐藏属性需要使用lsattr命令:

```bash
lsattr target_file
```
